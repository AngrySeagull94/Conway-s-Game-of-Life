<!DOCTYPE html>
<html>
<head>
	<title>Life</title>
	<meta charset="utf-8">
</head>

<body bgcolor="#ccc">

<div id="content_grid" style="display: grid; grid-template-columns: auto auto; justify-content: start;">
	<div id="content_canvas" style="grid-column: 1; margin: 10px; grid-row-start: 1;  grid-row-end: 5;">
		<canvas id='drawField'></canvas>
	</div>
	<div id="content_gui" style="grid-column: 2; margin: 10px;">
		<div id="gui_grid" style="display: grid; grid-template-columns: auto; justify-content: space-between;">
			<h1 style="grid-row: 1;">Conway's game of life</h1>
			<p style="text-align: center;">Simulation options</p>
			<div style="line-height: 4em;">
				Speed:
				<input type="range" id="sim_speed" name="sim_speed" min="10" max="1000" step="5" value="50" onchange="change_speed()">
				<label id="sim_speed_text" >50</label>
			</div>
			</table>
			<button id='pause_the_world' style="height: 5em; width: 10em;" onclick="handle_button()">Start</button>
		</div>
	</div>
</div>
<script type="text/javascript">

	class Context {
		constructor() {
			// UI parameters
			this.update_ms = 50
			this.update_interval_id = -1
			this.draw_interval_id   = -1
			this.sim_is_stopped = true
			this.can_use_mouse  = true
			this.draw_frame_id = 0
			this.canvas = undefined

			// Cell parameters
			this.size_of_cell = 10
			this.cell_number_vertical   = 0
			this.cell_number_horizontal = 0
			this.cell_color = "#00f2f2"

			// Map containers
			this.current_cycle_map = undefined
			this.previous_cycle_map    = undefined
		}
	}

	class Cell {
		constructor(v_index, h_index) {
			this.v = v_index
			this.h = h_index
			this.alive = false
		}
	}

	context = new Context()

	draw_canvas = document.getElementById('drawField')

	// ====== Main code ======
	init(draw_canvas)
	draw_timer = setInterval(draw, 50, draw_canvas)
	// =======================

	function init(canvas) {
		h = window.outerHeight * 0.8
		//w = window.innerWidth * 0.8
		w = h // square field

		context.cell_number_vertical = Math.floor(h / context.size_of_cell)
		context.cell_number_horizontal = Math.floor(w / context.size_of_cell)
		canvas.width  = context.cell_number_horizontal  * context.size_of_cell
		canvas.height = context.cell_number_vertical * context.size_of_cell

		context.canvas = canvas

		var curr_cycle = new Array(context.cell_number_vertical)
		var prev_cycle = new Array(context.cell_number_vertical)
		for (var i = curr_cycle.length - 1; i >= 0; i--) {
			curr_cycle[i] = new Array(context.cell_number_horizontal)
			prev_cycle[i] = new Array(context.cell_number_horizontal)
			for (var j = curr_cycle[i].length - 1; j >= 0; j--) {
				curr_cycle[i][j] = new Cell(i, j)
				prev_cycle[i][j] = new Cell(i, j)
			}
		}

		context.current_cycle_map  = curr_cycle
		context.previous_cycle_map = prev_cycle


		console.log('Create life field ', context.cell_number_horizontal, 'x', context.cell_number_vertical)

		canvas.addEventListener("mousedown", function(event){ doMouseDown(canvas, event) }, false)

		// Set simulation speed
		var range = document.getElementById('sim_speed')
		range.value = range.defaultValue
		change_speed()
	}

	function update() {
		var new_cycle  = context.previous_cycle_map
		var curr_cycle = context.current_cycle_map
		for (var i = curr_cycle.length - 1; i >= 0; i--) {
			var cell_row = curr_cycle[i]
			for (var j = cell_row.length - 1; j >= 0; j--) {
				cell = cell_row[j]

				//Wrap boundaries if needed
				v_pos = i
				h_pos = j
				up_index    = v_pos - 1
				down_index  = v_pos + 1
				left_index  = h_pos - 1
				right_index = h_pos + 1
				if (up_index < 0)                    { up_index    = curr_cycle.length - 1 }
				if (down_index >= curr_cycle.length) { down_index  = 0                     }
				if (left_index < 0)                  { left_index  = cell_row.length - 1   }
				if (right_index >= cell_row.length)  { right_index = 0                     }

				new_cycle[i][j].alive = false

				//Gather adjacent cells status
				population =
				  (curr_cycle[up_index][h_pos].alive === true? 1: 0) +
				  (curr_cycle[up_index][right_index].alive === true? 1: 0) +
				  (curr_cycle[v_pos][right_index].alive === true? 1: 0) +
				  (curr_cycle[down_index][right_index].alive === true? 1: 0) +
				  (curr_cycle[down_index][h_pos].alive === true? 1: 0) +
				  (curr_cycle[down_index][left_index].alive === true? 1: 0) +
				  (curr_cycle[v_pos][left_index].alive === true? 1: 0) +
				  (curr_cycle[up_index][left_index].alive === true? 1: 0)
				if (population < 2 || population > 3) {
					new_cycle[i][j].alive = false
					continue
				}
				if ((cell.alive === true) && (population >= 2 && population < 4)) {
					new_cycle[i][j].alive = true
					continue
				}
				if ((cell.alive === false) && (population === 3)) {
					new_cycle[i][j].alive = true
					continue
				}
			}
		}
		context.previous_cycle_map = curr_cycle
		context.current_cycle_map  = new_cycle
	}

	function doMouseDown(canvas, event) {
		const rect = canvas.getBoundingClientRect()
		const x = event.clientX - rect.left
		const y = event.clientY - rect.top
		//console.log("x: " + x + " y: " + y)
		if (context.can_use_mouse) {
			h_index = Math.floor(x / context.size_of_cell)
			v_index = Math.floor(y / context.size_of_cell)
			context.current_cycle_map[v_index][h_index].alive = true
		}
	}

	function draw(canvas) {
		context.draw_frame_id += 1
		//console.log(draw_frame_id)
		var ctx = canvas.getContext('2d')
		// Reset field
		ctx.fillStyle = "#555"
		ctx.fillRect(0,0,canvas.width, canvas.height)
		//draw_lines(ctx)
		draw_cells(ctx)
		ctx.stroke()
	}

	function draw_lines(ctx) {
		// Create rows and columns
		ctx.strokeStyle = "#666"
		ctx.lineWidth = 1
		// Rows
		ctx.beginPath()
		for (var i = context.cell_number_vertical - 1; i >= 0; i--) {
			y = i * context.size_of_cell - 0.5
			ctx.moveTo(0, y)
			ctx.lineTo(draw_canvas.height, y)
		}
		// Columns
		for (var i = context.cell_number_horizontal - 1; i >= 0; i--) {
			x = i * context.size_of_cell - 0.5
			ctx.moveTo(x, 0)
			ctx.lineTo(x, draw_canvas.width)
		}
		ctx.closePath()
	}

	function draw_cells(ctx) {
		ctx.fillStyle = context.cell_color
		for (var i = context.current_cycle_map.length - 1; i >= 0; i--) {
			var cell_row = context.current_cycle_map[i]
			for (var j = cell_row.length - 1; j >= 0; j--) {
				cell = cell_row[j]
				if (cell.alive === false)
					continue
				ctx.fillRect(j * context.size_of_cell,
				             i * context.size_of_cell,
				             context.size_of_cell,
				             context.size_of_cell)
			}
		}
	}

	function handle_button() {
		context.sim_is_stopped = !context.sim_is_stopped
		document.getElementById('pause_the_world').innerHTML = context.sim_is_stopped ? "Start" : "Stop"
		if (context.sim_is_stopped) {
			clearInterval(context.update_interval_id)
			context.update_interval_id = -1
		} else {
			context.update_interval_id = setInterval(update, context.update_ms)
		}
		console.log('Simulation is ', context.sim_is_stopped ? "stopped" : "resumed")
	}

	function change_speed() {
		var range = document.getElementById('sim_speed')
		context.update_ms = range.value
		console.log("Simulation speed changed to ", context.update_ms)
		document.getElementById('sim_speed_text').innerHTML = context.update_ms
		if (!context.sim_is_stopped)
		{
			clearInterval(context.update_interval_id)
			context.update_interval_id = setInterval(update, context.update_ms)
		}
	}

	</script>
	</body>
</html>
